// clean up 까지

import React, {useState, useEffect} from 'react';
import './App.css';

function App() {
  return (
    <div className="container">
      <h1>Hello World</h1>

      <FuncComp initNumber={2} />  
      <ClassComp initNumber={2} /> 
    </div>
  );
}

var funcStyle = 'color:blue';
var funcId = 0;
function FuncComp(props) {
 var numberState = useState(props.initNumber);
 var number = numberState[0];
 var setNumber = numberState[1]; //상태 바꾸는 함수

 var dateState = useState((new Date()).toString());
 var _date = dateState[0];
 var setDate = dateState[1];

 useEffect(function(){
    console.log('%cfunc => useEffect (componentDidMount & componentDidUpdate) '+(++funcId), funcStyle);
    document.title = number + ' : ' + _date;
  });
// hook 부분은 render가 끝날때 실행, update마다 componentDidMount & componentDidUpdate와 같은 효과
 console.log('%cfunc => render '+(++funcId), funcStyle);
/*
    return function(){
      console.log('%cfunc => useEffect return (componentDidMount & componentDidUpdate) '+(++funcId), funcStyle);
    }
      clean up은 useEffect 훅이 반환하는 함수로, 컴포넌트가 언마운트되거나 다음 렌더링 전에 실행
  skipping effect는 useEffect 훅의 두 번째 인수로 전달된 의존성 배열을 사용하여 특정 조건에서만 이펙트를 실행하도록 제어하는 것.
  의존성 배열에는 이펙트가 의존하는 값들을 나열

      */


 return (
  <div className="container">
    <h2>function style component</h2>
    <p>Number: {number}</p>
    <p>Date : {_date}</p>

    <input type="button" value="random" onClick={() => {
      setNumber(Math.random());
    }} />
    <input type="button" value="date" onClick={() => {
      setDate((new Date()).toString());
    }} />
  </div>
);
}
//함수 component 생성 -> return 
/*
함수를 raect가 호출할때 첫번째 파라미터 인자값으로 전달된 props값 전달
-> <FuncComp> initNumber ={2} />  */

var classStyle = 'color:red';
class ClassComp extends React.Component {
  state = {
    number: this.props.initNumber, // 초기값 설정
    date: (new Date()).toString() // date 속성 추가
  
  }  


  componentWillMount(){
    console.log('%cclass => componentWillMount', classStyle);
  }
  componentDidMount(){
    console.log('%cclass => componentDidMount', classStyle);
  }
  shouldComponentUpdate(nextProps, nextState){
    console.log('%cclass => shouldComponentUpdate', classStyle);
    return true;
  } // render 메서드 호출 여부 결정 (true -> render 계속 진행, false -? 렌더링 과정 중단, componentWillUpdate 호출x)
  componentWillUpdate(nextProps, nextState){
    console.log('%cclass => componentWillUpdate', classStyle);
  }
  componentDidUpdate(nextProps, nextState){
    console.log('%cclass => componentDidUpdate', classStyle);
  }

  render() {
    console.log('%cclass => render', classStyle);
    return (
      <div className="container">
        <h2>class style component</h2>
        <p>Number: {this.state.number}</p> 
        <p>Date : {this.state.date}</p>
        <input type="button" value="random" onClick={() => this.setState({ number: Math.random() })} />
        <input type="button" value="date" onClick={() => this.setState({ date: (new Date()).toString() })} />

      </div>
      //state값 초기화 및 변경 (기존 func에서는 안됐음. class의 장점)
    );
  }
}

export default App;
